<?php

/**
 * Builder data handling class that deals
 * with all database operations.
 *
 * @class FLBuilderModel
 */
final class FLBuilderModel {

    /**
     * @property $row_layouts
     * @type array
     */
    static public $row_layouts = array(
        '1-col'                 => array(100),
        '2-cols'                => array(50, 50),
        '3-cols'                => array(33.33, 33.33, 33.33),
        '4-cols'                => array(25, 25, 25, 25),
        '5-cols'                => array(20, 20, 20, 20, 20),
        '6-cols'                => array(16.65, 16.65, 16.65, 16.65, 16.65, 16.65),
        'left-sidebar'          => array(33.33, 66.66),
        'right-sidebar'         => array(66.66, 33.33),
        'left-right-sidebar'    => array(25, 50, 25)
    );

    /**
     * @property $settings_forms
     * @type array
     */
    static public $settings_forms = array();

    /**
     * @property $settings_form_defaults
     * @type array
     */
    static public $settings_form_defaults = array();

    /**
     * @property $modules
     * @type array
     */
    static public $modules = array();

    /**
     * The last node id that was generated by the builder.
     * This is saved to ensure the next node id is unique.
     *
     * @property $last_generated_node_id
     * @type string
     * @private
     */
    static private $last_generated_node_id = null;

    /**
     * Cached post data from either the $_POST array
     * or from the json decoded fl_builder_data post variable.
     *
     * @property $post_data
     * @type array
     * @private
     */
    static private $post_data = null;

    /**
     * An array of cached published layout data by post_id.
     *
     * @property $published_layout_data
     * @type array
     * @private
     */
    static private $published_layout_data = array();

    /**
     * An array of cached draft layout data by post_id.
     *
     * @property $draft_layout_data
     * @type array
     * @private
     */
    static private $draft_layout_data = array();

	/**
	 * All database updates should be made through
	 * this method for security.
	 *
     * @method update
     */
	static public function update($method = null, $params = array())
	{
	    $post_data  = self::get_post_data();
        $method     = isset($post_data['method']) ? $post_data['method'] : $method;
        $post_id    = self::get_post_id();

        // User can't edit this post.
        if($post_id && !current_user_can('edit_post', $post_id)) {
            return false;
        }

        // Method doesn't exist.
        else if(!$method) {
            return false;
        }

        // Method exists.
        else if(method_exists('FLBuilderModel', $method)) {

            // Call the method.
            $result = call_user_func_array('FLBuilderModel::' . $method, $params);

            // Render new assets.
            if(!isset($post_data['render_assets']) || $post_data['render_assets'] == 1) {
                FLBuilder::render_css();
                FLBuilder::render_js();
            }

            // Return the result.
            if(defined('DOING_AJAX')) {
                echo json_encode($result);
                die();
            }
            else {
                return $result;
            }
        }

        return false;
	}

    /**
     * @method get_edit_url
     */
    static public function get_edit_url( $post_id = false )
    {
        global $post;

        if ( false === $post_id ) {
            $post_id = $post->ID;
        }

        $url = add_query_arg( 'fl_builder', '', get_permalink( $post_id ) );

        if ( class_exists( 'WPMinify' ) ) {
            $url = add_query_arg( 'wp-minify-off', '1', $url );
        }

        return set_url_scheme( $url );
    }

    /**
     * @method get_upgrade_url
     */
    static public function get_upgrade_url( $params = array() )
    {
		$url = FL_BUILDER_UPGRADE_URL . '?' . http_build_query( $params, '', '&' );
		
		return apply_filters( 'fl_builder_upgrade_url', $url );
    }

	/**
     * @method get_post_data
     */
	static public function get_post_data()
	{
        if(!self::$post_data) {

            self::$post_data = array();

            if(isset($_POST['fl_builder_data'])) {

                $data = self::json_decode_settings($_POST['fl_builder_data']);

                foreach($data as $key => $val) {
                    self::$post_data[$key] = $val;
                }
            }
            else if(isset($_POST)) {

                foreach($_POST as $key => $val) {
                    self::$post_data[$key] = $val;
                }
            }
        }

        return self::$post_data;
	}

	/**
     * @method update_post_data
     */
	static public function update_post_data($key, $value)
	{
	    $post_data = self::get_post_data();
	    $post_data[$key] = $value;
	    self::$post_data = $post_data;
	}

	/**
     * @method get_post_types
     */
	static public function get_post_types()
	{
    	$key        = '_fl_builder_post_types';
    	$default    = array('page', 'fl-builder-template');

	    // Get the value.
    	if(is_network_admin()) {
        	$value = get_site_option($key);
    	}
    	else if(class_exists('FLBuilderMultisiteSettings')) {
        	$value = get_option($key);
        	$value = !$value ? get_site_option($key) : $value;
        }
        else {
            $value = get_option($key);
        }

    	// Return the value.
	    if(!$value) {
    	    return $default;
	    }
	    else {
    	    $value[] = 'fl-builder-template';
    	    return $value;
	    }
	}

	/**
     * @method get_global_posts
     */
	static public function get_global_posts()
	{
	    return apply_filters('fl_builder_global_posts', array());
	}

	/**
     * @method get_post_id
     */
	static public function get_post_id()
	{
        global $post;

        $post_data = self::get_post_data();

        if(isset($post_data['post_id'])) {
            return $post_data['post_id'];
        }
        else if(isset($post)) {
            return $post->ID;
        }
        else {
            return false;
        }
	}

    /**
     * @method is_ssl
     */
    static public function is_ssl()
    {
	    if ( is_ssl() ) {
		    return true;
	    }
	    else if ( 0 === stripos( get_option( 'siteurl' ), 'https://' ) ) {
		    return true;
	    }
	    else if ( isset( $_SERVER['HTTP_X_FORWARDED_PROTO'] ) && 'https' == $_SERVER['HTTP_X_FORWARDED_PROTO'] ) {
		    return true;
	    }
	    
        return false;
    }

    /**
     * Checks to see if the builder can be enabled for
     * the current post in the main query.
     *
     * @method is_post_editable
     */
    static public function is_post_editable()
    {
    	global $wp_the_query;

        if ( is_singular() && isset( $wp_the_query->post ) ) {

            $post       = $wp_the_query->post;
            $post_types = self::get_post_types();
            $user_can   = current_user_can( 'edit_post', $post->ID );

            if ( in_array( $post->post_type, $post_types ) && $user_can ) {
                return true;
            }
        }

        return false;
    }

    /**
     * Called by the heartbeat API. Lock the current post
     * so only the current user can edit it.
     *
     * @method lock_post
     */
    static public function lock_post($response, $data)
    {
        if(isset($data['fl_builder_post_lock'])) {

            require_once ABSPATH . 'wp-admin/includes/post.php';

            wp_set_post_lock($data['fl_builder_post_lock']['post_id']);
        }
    }

	/**
	 * Checks to see if the builder layout is enabled
	 * for the current post.
	 *
     * @method is_builder_enabled
     */
	static public function is_builder_enabled()
	{
	    if(!is_admin() && post_password_required()) {
    	    return false;
	    }
	    else if(self::is_builder_active()) {
    	    return true;
	    }
	    else {

	        $post_types = self::get_post_types();
    	    $post       = get_post(self::get_post_id());

    	    if($post && in_array($post->post_type, $post_types)) {
        	    return get_post_meta(self::get_post_id(), '_fl_builder_enabled', true);
    	    }
	    }

        return false;
	}

	/**
	 * Checks to see if the builder UI is active for
	 * the current post in the main query.
	 *
     * @method is_builder_active
     */
	static public function is_builder_active()
	{
    	if ( self::is_post_editable() && ! is_admin() && ! post_password_required() ) {

        	$post_data = self::get_post_data();

            if ( isset( $_GET['fl_builder'] ) ) {
            	return true;
        	}
        	else if ( isset( $post_data['fl_builder'] ) ) {
            	return true;
        	}
    	}

    	return false;
	}

	/**
	 * Gets the status to use for working with nodes in
	 * the database. Returns draft if the builder is active,
	 * otherwise it returns published.
	 *
     * @method get_node_status
     */
	static public function get_node_status()
	{
        return self::is_builder_active() ? 'draft' : 'published';
	}

	/**
	 * Enable the builder layout for the current post.
	 *
     * @method enable
     */
	static public function enable()
	{
        update_post_meta(self::get_post_id(), '_fl_builder_enabled', true);
	}

	/**
	 * Disable the builder layout for the current post.
	 *
     * @method disable
     */
	static public function disable()
	{
        update_post_meta(self::get_post_id(), '_fl_builder_enabled', false);
	}

	/**
	 * Enable the builder editor for the main post in the query.
	 *
     * @method enable_editing
     */
	static public function enable_editing()
	{
    	global $wp_the_query;

        if ( self::is_post_editable() ) {

    	    $post       = $wp_the_query->post;
    	    $published  = self::get_layout_data( 'published' );
    	    $draft      = self::get_layout_data( 'draft' );

    	    // Migrate existing post content to the builder?
    	    if ( empty( $published ) && empty( $draft ) && ! empty( $post->post_content ) ) {

                $row            = self::add_row();
                $cols           = self::get_nodes( 'column' );
        	    $col            = array_shift( $cols );
                $settings       = self::get_module_defaults( 'rich-text' );
                $settings->text = wpautop( $post->post_content );

                self::add_module( 'rich-text', $settings, $col->node );
    	    }
    	    // Create a new draft?
    	    else if ( empty( $draft ) ) {
    	        self::update_layout_data( $published, 'draft', $post->ID );
    	    }

            // Delete old draft asset cache.
            self::delete_asset_cache();

            // Lock the post.
            require_once ABSPATH . 'wp-admin/includes/post.php';
            wp_set_post_lock( $post->ID );
        }
	}

	/**
     * @method get_upload_dir
     */
	static public function get_upload_dir()
	{
        $wp_info  = wp_upload_dir();
        $dir_name = basename( FL_BUILDER_DIR );
        
        // We use bb-plugin for the lite version as well.
        if ( $dir_name == 'beaver-builder-lite-version' ) {
	        $dir_name = 'bb-plugin';
        }

        // SSL workaround.
        if ( self::is_ssl() ) {
            $wp_info['baseurl'] = str_ireplace( 'http://', 'https://', $wp_info['baseurl'] );
        }

        // Build the paths.
        $dir_info = array(
            'path'   => $wp_info['basedir'] . '/' . $dir_name . '/',
            'url'    => $wp_info['baseurl'] . '/' . $dir_name . '/'
        );

        // Create the upload dir if it doesn't exist.
        if ( ! file_exists( $dir_info['path'] ) ) {
            mkdir( $dir_info['path'] );
        }

        return $dir_info;
    }

	/**
     * @method get_cache_dir
     */
	static public function get_cache_dir( $name = 'cache' )
	{
        $upload_info = self::get_upload_dir();
        $allowed     = array( 'cache', 'icons' );
        
        // Make sure the dir name is allowed.
        if ( ! in_array( $name, $allowed ) ) {
	        return false;
        }

        // Build the paths.
        $dir_info = array(
            'path'   => $upload_info['path'] . $name . '/',
            'url'    => $upload_info['url'] . $name . '/'
        );

        // Create the cache dir if it doesn't exist.
        if( ! file_exists( $dir_info['path'] ) ) {
            mkdir( $dir_info['path'] );
        }

        return $dir_info;
    }

	/**
     * @method get_asset_version
     */
	static public function get_asset_version()
	{
	    $post_id = self::get_post_id();
	    $active  = self::is_builder_active();

	    if($active) {
	        return md5(uniqid());
        }
        else {
	        return md5(get_post_modified_time('U', false, $post_id));
        }
	}

	/**
     * @method get_asset_info
     */
	static public function get_asset_info()
	{
	    $post_data = self::get_post_data();
        $post_id   = self::get_post_id();
        $cache_dir = self::get_cache_dir();

        if(isset($post_data['node_preview'])) {
            $suffix = '-layout-preview';
        }
        else if(self::is_builder_active()) {
            $suffix = '-layout-draft';
        }
        else {
            $suffix = '-layout';
        }

        $info = array(
            'css'     => $cache_dir['path'] . $post_id . $suffix . '.css',
            'css_url' => $cache_dir['url']  . $post_id . $suffix . '.css',
            'js'      => $cache_dir['path'] . $post_id . $suffix . '.js',
            'js_url'  => $cache_dir['url']  . $post_id . $suffix . '.js'
        );

        return $info;
    }

	/**
     * @method delete_asset_cache
     */
	static public function delete_asset_cache($type = 'all')
	{
        $info = self::get_asset_info();

        if(($type == 'css' || $type == 'all') && file_exists($info['css'])) {
            unlink($info['css']);
        }
        if(($type == 'js' || $type == 'all') && file_exists($info['js'])) {
            unlink($info['js']);
        }
	}

	/**
     * @method delete_all_asset_cache
     */
	static public function delete_all_asset_cache($post_id = null)
	{
        $post_id 	= $post_id == null ? self::get_post_id() : $post_id;
        $cache_dir 	= self::get_cache_dir();

	    if($post_id == null) {
    	    array_map('unlink', glob($cache_dir['path'] . '*.css'));
    	    array_map('unlink', glob($cache_dir['path'] . '*.js'));
	    }
        else {
            $css         = $cache_dir['path'] . $post_id . '-layout.css';
            $css_draft   = $cache_dir['path'] . $post_id . '-layout-draft.css';
            $css_preview = $cache_dir['path'] . $post_id . '-layout-preview.css';
            $js          = $cache_dir['path'] . $post_id . '-layout.js';
            $js_draft    = $cache_dir['path'] . $post_id . '-layout-draft.js';
            $js_preview  = $cache_dir['path'] . $post_id . '-layout-preview.js';

            if(file_exists($css)) {
                unlink($css);
            }
            if(file_exists($css_draft)) {
                unlink($css_draft);
            }
            if(file_exists($css_preview)) {
                unlink($css_preview);
            }
            if(file_exists($js)) {
                unlink($js);
            }
            if(file_exists($js_draft)) {
                unlink($js_draft);
            }
            if(file_exists($js_preview)) {
                unlink($js_preview);
            }
        }
	}

	/**
     * @method generate_node_id
     */
    static public function generate_node_id()
    {
        $node_id = uniqid();

        if($node_id == self::$last_generated_node_id) {
            return self::generate_node_id();
        }

        self::$last_generated_node_id = $node_id;

        return $node_id;
    }

	/**
     * @method generate_new_node_ids
     */
    static public function generate_new_node_ids($data)
    {
        $map   = array();
        $nodes = array();

        // Map the new node ids to the old.
        foreach($data as $node_id => $node) {
            $map[$node_id] = self::generate_node_id();
        }

        // Replace the old node ids.
        foreach($data as $node_id => $node) {

            $nodes[$map[$node_id]]       = $node;
            $nodes[$map[$node_id]]->node = $map[$node_id];

            if(!empty($node->parent) && isset($map[$node->parent])) {
                $nodes[$map[$node_id]]->parent = $map[$node->parent];
            }
        }

        return $nodes;
    }

	/**
     * @method get_node
     */
	static public function get_node($node_id = null, $status = null)
	{
	    $data = self::get_layout_data($status);
	    $node = $data[$node_id];

	    if(isset($node) && !empty($node->settings)) {
	        $node->settings = self::get_node_settings($node);
        }

	    return $node;
	}

	/**
     * @method get_child_nodes
     */
	static public function get_child_nodes($parent_id, $status = null)
	{
	    $data  = self::get_layout_data($status);
	    $nodes = array();

	    foreach($data as $node_id => $node) {

    	    if($node->parent == $parent_id) {
        	    $nodes[$node_id] = $node;
    	    }
	    }

	    return $nodes;
	}

	/**
     * @method get_nodes
     */
	static public function get_nodes($type = null, $parent_id = null, $status = null)
	{
        $nodes = array();

	    // Get the layout data.
	    if($parent_id == null) {
    	    $data = self::get_layout_data($status);
	    }
	    else {
    	    $data = self::get_child_nodes($parent_id, $status);
	    }

	    // Return all nodes?
	    if($type == null) {
    	    $nodes = $data;
	    }
	    // Return nodes of a certain type.
	    else {

    	    foreach($data as $node_id => $node) {

        	    if($node->type == $type) {
            	    $nodes[$node_id] = $node;
        	    }
    	    }

    	    uasort($nodes, array('FLBuilderModel', 'order_nodes'));
	    }

	    // Merge default settings.
	    foreach($nodes as $node_id => $node) {

	        if(!empty($node->settings)) {
	            $nodes[$node_id]->settings = self::get_node_settings($nodes[$node_id]);
            }
	    }

	    // Return the nodes.
	    return $nodes;
	}

	/**
     * @method get_node_settings
     */
	static public function get_node_settings($node)
	{
	    $post_data = self::get_post_data();

	    if(isset($post_data['node_preview']) && isset($post_data['node_id']) && $post_data['node_id'] == $node->node) {

    	    if(!isset($post_data['node_preview_processed_settings'])) {
                $settings = $post_data['node_preview'];
                $settings = (object)array_merge((array)$node->settings, (array)$settings);
                $settings = self::process_node_settings($node, $settings);
                self::update_post_data('node_preview_processed_settings', $settings);
            }
            else {
                $settings = $post_data['node_preview_processed_settings'];
            }
        }
        else {
            $defaults = self::get_node_defaults($node);
            $settings = (object)array_merge((array)$defaults, (array)$node->settings);
        }

        return $settings;
	}

	/**
     * @method process_node_settings
     */
	static public function process_node_settings($node, $new_settings)
	{
	    if($node->type == 'row') {
            $new_settings = self::process_row_settings($node, $new_settings);
        }
        if($node->type == 'column') {
            $new_settings = self::process_col_settings($node, $new_settings);
        }
        if($node->type == 'module') {
            $new_settings = self::process_module_settings($node, $new_settings);
        }

        return $new_settings;
	}

	/**
     * @method get_node_defaults
     */
	static public function get_node_defaults($node)
	{
	    $defaults = array();

	    if($node->type == 'row') {
            $defaults = self::get_row_defaults();
        }
        else if($node->type == 'column') {
            $defaults = self::get_col_defaults();
        }
        else if($node->type == 'module') {
            $defaults = self::get_module_defaults($node->settings->type);
        }

        return $defaults;
	}

	/**
     * @method order_nodes
     */
	static public function order_nodes($a, $b)
	{
	    return (int)$a->position - (int)$b->position;
	}

	/**
     * @method count_nodes
     */
	static public function count_nodes($type = 'row', $parent_id = null)
	{
	    return count(self::get_nodes($type, $parent_id));
	}

	/**
     * @method next_node_position
     */
	static public function next_node_position($type = 'row', $parent_id = null)
	{
	    $nodes = self::get_nodes($type, $parent_id);
	    $last  = array_pop($nodes);

	    return $last ? $last->position + 1 : 0;
	}

	/**
     * @method delete_node
     */
    static public function delete_node($node_id = null)
    {
        // Get the post data.
        $post_data = self::get_post_data();

        // Get the layout data.
        $data = self::get_layout_data();

        // Get the node id.
        if(!$node_id && isset($post_data['node_id'])) {
            $node_id = $post_data['node_id'];
        }

        // Return if the node doesn't exist.
        if(!isset($data[$node_id])) {
            return;
        }

        // Get the node.
        $node = $data[$node_id];

        // Call the delete method if we're deleting a module.
        self::call_module_delete($node);

        // Delete the node.
        unset($data[$node_id]);

        // Update the layout data.
        self::update_layout_data($data);

        // Reorder existing nodes.
        self::reorder_nodes($node->type, $node->parent);

        // Delete the node's children.
        self::delete_child_nodes($node_id);
    }

	/**
     * @method delete_child_nodes
     */
    static public function delete_child_nodes($parent_id = null)
    {
        $children = self::get_nodes(null, $parent_id);

        foreach($children as $child) {
            self::delete_node($child->node);
        }
    }

	/**
     * @method call_module_delete
     */
    static public function call_module_delete($node)
    {
        if($node->type == 'module' && isset(self::$modules[$node->settings->type])) {
            $class = get_class(self::$modules[$node->settings->type]);
            $instance = new $class();
            $instance->settings = $node->settings;
            $instance->delete();
        }
    }

	/**
     * @method reorder_node
     */
    static public function reorder_node($node_id = null, $position = 0)
    {
        $post_data  = self::get_post_data();
        $data       = self::get_layout_data();
        $node_id 	= $node_id != null ? $node_id : $post_data['node_id'];
        $node 		= $data[$node_id];
        $nodes 		= self::get_nodes($node->type, $node->parent);
        $position 	= isset($post_data['position']) ? (int)$post_data['position'] : $position;
        $new_pos    = 0;

        // Make sure node positions start at zero.
        foreach($nodes as $node) {
            $data[$node->node]->position = $new_pos;
            $new_pos++;
        }

        // Get the node and remove it from the array.
        $node 		= $data[$node_id];
        $removed 	= array_splice($nodes, $node->position, 1);
        $new_pos    = 0;

        // Reposition it in the array.
        array_splice($nodes, $position, 0, $removed);

        // Update the position data.
        foreach($nodes as $node) {
            $data[$node->node]->position = $new_pos;
            $new_pos++;
        }

        // Update the layout data.
        self::update_layout_data($data);
    }

	/**
     * @method reorder_nodes
     */
    static public function reorder_nodes($type = 'row', $parent_id = null)
    {
        $data  = self::get_layout_data();
        $nodes = self::get_nodes($type, $parent_id);
        $pos   = 0;

        foreach($nodes as $node_id => $node) {
            $data[$node_id]->position = $pos;
            $pos++;
        }

        self::update_layout_data($data);
    }

	/**
     * @method move_node
     */
    static public function move_node($node_id = null, $new_parent_id = null, $position = 0)
    {
        $post_data      = self::get_post_data();
        $data           = self::get_layout_data();
        $node_id        = isset($post_data['node_id']) ? $post_data['node_id'] : $node_id;
        $new_parent_id  = isset($post_data['new_parent']) ? $post_data['new_parent'] : $new_parent_id;
        $position       = isset($post_data['position']) ? $post_data['position'] : $position;
        $new_parent     = self::get_node($new_parent_id);
        $node           = self::get_node($node_id);

        // Set the node's new parent.
        $data[$node_id]->parent = $new_parent->node;

        // Update the layout data.
        self::update_layout_data($data);

        // Set the node's new order.
        self::reorder_node($node_id, $position);
    }

	/**
     * @method add_row
     */
    static public function add_row($cols = '1-col', $position = false)
    {
        $post_data       = self::get_post_data();
        $data            = self::get_layout_data();
        $cols            = isset($post_data['cols']) ? $post_data['cols'] : $cols;
        $position        = isset($post_data['position']) ? (int)$post_data['position'] : $position;
        $settings        = self::get_row_defaults();
        $row_node_id     = self::generate_node_id();

        // Add the row.
        $data[$row_node_id]            = new StdClass();
        $data[$row_node_id]->node      = $row_node_id;
        $data[$row_node_id]->type      = 'row';
        $data[$row_node_id]->parent    = null;
        $data[$row_node_id]->position  = self::next_node_position('row');
        $data[$row_node_id]->settings  = $settings;

        // Update the layout data.
        self::update_layout_data($data);

        // Position the row.
        if($position !== false) {
            self::reorder_node($row_node_id, $position);
        }

        // Add a column group.
        self::add_col_group($row_node_id, $cols, 0);

        // Return the updated row.
        return self::get_node($row_node_id);
    }

	/**
     * @method copy_row
     */
    static public function copy_row($node_id = null)
    {
	    $post_data      = self::get_post_data();
        $node_id        = isset($post_data['node_id']) ? $post_data['node_id'] : $node_id;
        $layout_data    = self::get_layout_data();
        $row            = self::get_node($node_id);
        $new_row_id     = self::generate_node_id();
        $col_groups     = self::get_child_nodes($node_id);
        $new_nodes      = array();

        // Add the new row.
        $layout_data[$new_row_id]           = clone $row;
        $layout_data[$new_row_id]->settings = clone $row->settings;
        $layout_data[$new_row_id]->node     = $new_row_id;

        // Get the new child nodes.
        foreach($col_groups as $col_group_id => $col_group) {

            $new_nodes[$col_group_id] = clone $col_group;
            $cols                     = self::get_child_nodes($col_group_id);

            foreach($cols as $col_id => $col) {

                $new_nodes[$col_id]             = clone $col;
                $new_nodes[$col_id]->settings   = clone $col->settings;
                $modules                        = self::get_child_nodes($col_id);

                foreach($modules as $module_id => $module) {
                    $new_nodes[$module_id]             = clone $module;
                    $new_nodes[$module_id]->settings   = clone $module->settings;
                }
            }
        }

		// Generate new child ids.
        $new_nodes = self::generate_new_node_ids($new_nodes);

        // Set col group parent ids to the new row id.
        foreach($new_nodes as $child_node_id => $child) {
            if($child->type == 'column-group') {
                $new_nodes[$child_node_id]->parent = $new_row_id;
            }
        }

        // Merge the child data.
        $layout_data = array_merge($layout_data, $new_nodes);

        // Update the layout data.
        self::update_layout_data($layout_data);

        // Position the new row.
        self::reorder_node($new_row_id, $row->position + 1);
    }

    /**
     * @method get_row_defaults
     */
    static public function get_row_defaults()
    {
        return self::get_settings_form_defaults( 'row' );
    }

    /**
     * @method process_row_settings
     */
    static public function process_row_settings($row, $new_settings)
    {
        // Cache background video data.
        if($new_settings->bg_type == 'video') {

            // Video
            $video = FLBuilderPhoto::get_attachment_data($new_settings->bg_video);

            if($video) {

                $parts = explode('.', $video->filename);
                $video->extension = array_pop($parts);
                $new_settings->bg_video_data = $video;

                // Fallback
                if(!empty($new_settings->bg_video_fallback_src)) {
                    $new_settings->bg_video_data->fallback = $new_settings->bg_video_fallback_src;
                }
                else {
                    $new_settings->bg_video_data->fallback = '';
                }
            }
        }

        // Cache background slideshow data.
        if($new_settings->bg_type == 'slideshow' && $new_settings->ss_source == 'wordpress') {

            // Make sure we have a photo data object.
            if(!isset($row->settings->ss_photo_data)) {
                $row->settings->ss_photo_data = new StdClass();
            }

            // Hijack the slideshow module to get WordPress photo data.
            $ss                             = new FLSlideshowModule();
            $ss->settings                   = new StdClass();
            $ss->settings->photos           = $new_settings->ss_photos;
            $ss->settings->photo_data       = $row->settings->ss_photo_data;
            $new_settings->ss_photo_data    = $ss->get_wordpress_photos();
        }

        return $new_settings;
    }

    /**
     * @method get_row_bg_data
     */
    static public function get_row_bg_data($row)
    {
        $data = null;

        // Background Video
        if($row->settings->bg_type == 'video' && isset($row->settings->bg_video_data)) {
            $data = $row->settings->bg_video_data;
        }

        // Background Slideshow
        else if($row->settings->bg_type == 'slideshow' && isset($row->settings->ss_photo_data)) {
            $data = $row->settings->ss_photo_data;
        }

        return $data;
    }

    /**
     * @method get_row_slideshow_source
     */
    static public function get_row_slideshow_source($row)
    {
        // Make sure we have a photo data object.
        if(!isset($row->settings->ss_photo_data)) {
            $row->settings->ss_photo_data = new StdClass();
        }

        // Hijack the slideshow module to get the source.
        $ss                             = new FLSlideshowModule();
        $ss->settings                   = new StdClass();
        $ss->settings->source           = $row->settings->ss_source;
        $ss->settings->photos           = $row->settings->ss_photos;
        $ss->settings->feed_url         = $row->settings->ss_feed_url;
        $ss->settings->photo_data       = $row->settings->ss_photo_data;

        // Return the slideshow source.
        return $ss->get_source();
    }

    /**
     * @method add_col_group
     */
    static public function add_col_group($node_id = null, $cols = '1-col', $position = false)
    {
        $post_data          = self::get_post_data();
        $data               = self::get_layout_data();
        $node_id            = isset($post_data['node_id']) ? $post_data['node_id'] : $node_id;
        $cols               = isset($post_data['cols']) ? $post_data['cols'] : $cols;
        $position           = isset($post_data['position']) ? (int)$post_data['position'] : $position;
        $group_node_id      = self::generate_node_id();

        // Add the column group.
        $data[$group_node_id]            = new StdClass();
        $data[$group_node_id]->node      = $group_node_id;
        $data[$group_node_id]->type      = 'column-group';
        $data[$group_node_id]->parent    = $node_id;
        $data[$group_node_id]->position  = self::next_node_position('column-group', $node_id);
        $data[$group_node_id]->settings  = '';

        // Add the columns.
        for($i = 0; $i < count(self::$row_layouts[$cols]); $i++) {

            $col_node_id                        = self::generate_node_id();
            $data[$col_node_id]                 = new StdClass();
            $data[$col_node_id]->node           = $col_node_id;
            $data[$col_node_id]->type           = 'column';
            $data[$col_node_id]->parent         = $group_node_id;
            $data[$col_node_id]->position       = $i;
            $data[$col_node_id]->settings       = new StdClass();
            $data[$col_node_id]->settings->size = self::$row_layouts[$cols][$i];
        }

        // Update the layout data.
        self::update_layout_data($data);

        // Position the column group.
        if($position !== false) {
            self::reorder_node($group_node_id, $position);
        }

        // Return the column group.
        return self::get_node($group_node_id);
    }

    /**
     * @method process_col_settings
     */
    static public function process_col_settings($col, $new_settings)
    {
        $new_settings->size = self::resize_col($col->node, $new_settings->size);

        return $new_settings;
    }

    /**
     * @method delete_col
     */
    static public function delete_col($node_id = null, $new_width = 100)
    {
        $post_data  = self::get_post_data();
        $node_id    = isset($post_data['node_id']) ? $post_data['node_id'] : $node_id;
        $new_width  = isset($post_data['new_width']) ? $post_data['new_width'] : $new_width;
        $col        = self::get_node($node_id);

        // Delete the column.
        self::delete_node($node_id);

        // Get the group
        $group = self::get_node($col->parent);

        // Get the group children.
        $cols = self::get_nodes('column', $group->node);

        // Delete the group if empty.
        if(count($cols) === 0) {
            self::delete_node($group->node);
        }

        // Resize the remaining columns.
        else {

            // Get the layout data.
            $data = self::get_layout_data();

            // Loop through the columns.
            foreach($cols as $col_id => $col) {

                // Set the new size.
                $data[$col_id]->settings->size = round($new_width, 2);
            }

            // Update the layout data.
            self::update_layout_data($data);
        }
    }

    /**
     * @method resize_col
     */
    static public function resize_col($node_id = null, $new_width = 100)
    {
        $data           = self::get_layout_data();
        $col            = $data[$node_id];
        $group          = $data[$col->parent];
        $cols           = array_values(self::get_nodes('column', $group->node));
        $pos            = $col->position;
        $siblings       = array();
        $siblings_width = 0;
        $num_cols       = count($cols);
        $min_width      = 10;
        $max_width      = 100 - $min_width;

        // Don't resize if only one column or width isn't a number.
        if($num_cols == 1 || !is_numeric($new_width)) {
            return $col->settings->size;
        }

        // Find the sibling column to absorb this resize.
        if($pos === 0) {
            $sibling = $cols[1];
        }
        else if($pos == $num_cols - 1) {
            $sibling = $cols[$num_cols - 2];
        }
        else {
            $sibling = $cols[$pos + 1];
        }

        // Find other siblings.
        foreach($cols as $c) {

            if($col->node == $c->node) {
                continue;
            }
            if($sibling->node == $c->node) {
                continue;
            }

            $siblings[]      = $c;
            $max_width      -= $c->settings->size;
            $siblings_width += $c->settings->size;
        }

        // Make sure the new width isn't too small.
        if($new_width < $min_width) {
            $new_width = $min_width;
        }

        // Make sure the new width isn't too big.
        if($new_width > $max_width) {
            $new_width = $max_width;
        }

        // Save new sibling size.
        $data[$sibling->node]->settings->size = round(100 - $siblings_width - $new_width, 2);

        // Save new column size.
        $data[$col->node]->settings->size = $new_width;

        // Update the layout data.
        self::update_layout_data($data);

        // Return the new size.
        return $new_width;
    }

    /**
     * @method get_col_defaults
     */
    static public function get_col_defaults()
    {
        return self::get_settings_form_defaults( 'col' );
    }

	/**
     * @method load_modules
     */
    static public function load_modules()
    {
        $path           = FL_BUILDER_DIR . 'modules/';
        $dir            = dir($path);
        $module_path    = '';

        while(false !== ($entry = $dir->read())) {

            if(!is_dir($path . $entry) || $entry == '.' || $entry == '..') {
                continue;
            }

            // Paths to check.
            $module_path    = $entry . '/' . $entry . '.php';
            $child_path     = get_stylesheet_directory() . '/fl-builder/modules/' . $module_path;
            $theme_path     = get_template_directory() . '/fl-builder/modules/' . $module_path;
            $builder_path   = FL_BUILDER_DIR . 'modules/' . $module_path;

            // Check for the module class in a child theme.
            if(is_child_theme() && file_exists($child_path)) {
                require_once $child_path;
            }

            // Check for the module class in a parent theme.
            else if(file_exists($theme_path)) {
                require_once $theme_path;
            }

            // Check for the module class in the builder directory.
            else if(file_exists($builder_path)) {
                require_once $builder_path;
            }
        }
    }

	/**
     * @method register_module
     */
    static public function register_module($class, $form)
    {
        if(class_exists($class)) {

            // Create a new instance of the module.
            $instance = new $class();
              
            // Log an error if a module with this slug already exists.
            if ( isset( self::$modules[ $instance->slug ] ) ) {
	            error_log( sprintf( _x( 'A module with the filename %s.php already exists! Please namespace your module filenames to ensure compatibility with Beaver Builder.', '%s stands for the module filename', 'fl-builder' ), $instance->slug ) );
	            return;
            }
            
            // See if the module is enabled or not. 
            $enabled = apply_filters( 'fl_builder_register_module', $instance->enabled, $instance );

            // Only register modules that are enabled.
            if( $enabled ) {

                // Save the instance in the modules array.
                self::$modules[$instance->slug] = $instance;

                // Add the form to the instance.
                self::$modules[$instance->slug]->form = $form;
                self::$modules[$instance->slug]->form['advanced'] = self::$settings_forms['module_advanced'];
            }
        }
    }

	/**
     * @method get_enabled_modules
     */
	static public function get_enabled_modules()
	{
    	$key        = '_fl_builder_enabled_modules';
    	$default    = array_keys(self::$modules);
	    $default[]  = 'all';

	    // Get the value.
    	if(is_network_admin()) {
        	$value = get_site_option($key);
    	}
    	else if(class_exists('FLBuilderMultisiteSettings')) {
        	$value = get_option($key);
        	$value = !$value ? get_site_option($key) : $value;
        }
        else {
            $value = get_option($key);
        }

    	// Return the value.
	    if(!$value || in_array('all', $value)) {
    	    return $default;
	    }
	    else {
    	    return $value;
	    }
	}

	/**
     * @method get_categorized_modules
     */
    static public function get_categorized_modules()
    {
        $enabled_modules = self::get_enabled_modules();

		$categories = array(
			'Basic Modules'     => array(),
			'Advanced Modules'  => array(),
			'Other'             => array()
		);

		// Build the categories array.
		foreach(self::$modules as $module) {

		    if(!in_array($module->slug, $enabled_modules)) {
    		    continue;
		    }
			else if($module->slug == 'widget') {
				$categories[$module->category] = self::get_wp_widgets();
			}
			else if(isset($module->category)) {

				if(!isset($categories[$module->category])) {
					$categories[$module->category] = array();
				}
				
				$categories[$module->category][$module->name] = $module;
			}
			else {
				$categories['Other'][$module->name] = $module;
			}
		}

		// Sort the modules.
		foreach($categories as $title => $modules) {
			if(count($categories[$title]) == 0) {
				unset($categories[$title]);
			}
			else {
				ksort($categories[$title]);
			}
		}

		// Return sorted categories.
		return $categories;
    }

    /**
     * @method get_module
     */
    static public function get_module($node_id)
    {
        $module = self::get_node($node_id);

        if(isset(self::$modules[$module->settings->type])) {

            $class              = get_class(self::$modules[$module->settings->type]);
            $instance           = new $class();
            $instance->node     = $module->node;
            $instance->parent   = $module->parent;
            $instance->position = $module->position;
            $instance->settings = $module->settings;
            $instance->type     = 'module';
            $instance->form     = self::$modules[$module->settings->type]->form;

            return $instance;
        }

        return false;
    }

    /**
     * @method get_modules
     */
    static public function get_modules($col_id = null)
    {
        $modules    = self::get_nodes('module', $col_id);
        $instances  = array();
        $i          = 0;

        foreach($modules as $module) {

            if(isset(self::$modules[$module->settings->type])) {

                $class                      = get_class(self::$modules[$module->settings->type]);
                $instances[$i]              = new $class();
                $instances[$i]->node        = $module->node;
                $instances[$i]->parent      = $module->parent;
                $instances[$i]->position    = $module->position;
                $instances[$i]->settings    = $module->settings;
                $instances[$i]->type        = 'module';
                $instances[$i]->form        = self::$modules[$module->settings->type]->form;
                $i++;
            }
        }

        return $instances;
    }

    /**
     * @method get_all_modules
     */
    static public function get_all_modules()
    {
        return self::get_modules();
    }

    /**
     * @method add_module
     */
    static public function add_module($type = null, $settings = array(), $parent_id = null, $position = false)
    {
        $post_data          = self::get_post_data();
        $data               = self::get_layout_data();
        $type 				= isset($post_data['type']) ? $post_data['type'] : $type;
        $settings 			= isset($post_data['settings']) ? $post_data['settings'] : $settings;
        $parent_id 			= isset($post_data['parent_id']) ? $post_data['parent_id'] : $parent_id;
        $position 			= isset($post_data['position']) ? (int)$post_data['position'] : $position;
        $module_node_id 	= self::generate_node_id();
        $settings->type 	= $type;

        // Run module update method.
        $class 					= get_class(self::$modules[$type]);
        $instance 				= new $class();
        $instance->settings 	= $settings;
        $settings 				= $instance->update($settings);

        // Save the module.
        $data[$module_node_id]            = new StdClass();
        $data[$module_node_id]->node      = $module_node_id;
        $data[$module_node_id]->type      = 'module';
        $data[$module_node_id]->parent    = $parent_id;
        $data[$module_node_id]->position  = self::next_node_position('module', $parent_id);
        $data[$module_node_id]->settings  = $settings;

        // Update the layout data.
        self::update_layout_data($data);

        // Position the module.
        if($position !== false) {
            self::reorder_node($module_node_id, $position);
        }

        // Send back the inserted module.
        return self::get_module($module_node_id);
    }

    /**
     * @method add_default_module
     */
    static public function add_default_module($parent_id = null, $type = null, $position = false)
    {
        $post_data      = self::get_post_data();
        $parent_id 	    = isset($post_data['parent_id']) ? $post_data['parent_id'] : $parent_id;
        $parent         = $parent_id == 0 ? null : self::get_node($parent_id);
        $type 		    = isset($post_data['type']) ? $post_data['type'] : $type;
        $position       = isset($post_data['position']) ? (int)$post_data['position'] : $position;
        $settings       = self::get_module_defaults($type);
        $module_node_id = self::generate_node_id();

        // Add a new row if we don't have a parent.
        if(!$parent) {
            $row        = self::add_row('1-col', $position);
            $col_groups = self::get_nodes('column-group', $row->node);
            $col_group  = array_shift($col_groups);
            $cols       = self::get_nodes('column', $col_group->node);
            $parent     = array_shift($cols);
            $parent_id  = $parent->node;
            $position   = null;
        }

        // Add a new column if the parent is a row.
        else if($parent->type == 'row') {
            $col_group  = self::add_col_group($parent->node, '1-col', $position);
            $cols       = self::get_nodes('column', $col_group->node);
            $parent     = array_shift($cols);
            $parent_id  = $parent->node;
            $position   = null;
        }

        // Run module update method.
        $class 					= get_class(self::$modules[$type]);
        $instance 				= new $class();
        $instance->settings 	= $settings;
        $settings 				= $instance->update($settings);

        // Save the module.
        $data                             = self::get_layout_data();
        $data[$module_node_id]            = new StdClass();
        $data[$module_node_id]->node      = $module_node_id;
        $data[$module_node_id]->type      = 'module';
        $data[$module_node_id]->parent    = $parent_id;
        $data[$module_node_id]->position  = self::next_node_position('module', $parent_id);
        $data[$module_node_id]->settings  = $settings;

        // Update the layout data.
        self::update_layout_data($data);

        // Position the module.
        if($position !== false) {
            self::reorder_node($module_node_id, $position);
        }

        // Send back the inserted module.
        return self::get_module($module_node_id);
    }

	/**
     * @method copy_module
     */
	static public function copy_module($node_id = null)
	{
	    $post_data  = self::get_post_data();
        $node_id    = isset($post_data['node_id']) ? $post_data['node_id'] : $node_id;
        $module     = self::get_module($node_id);

        return self::add_module($module->settings->type, $module->settings, $module->parent, $module->position + 1);
	}

	/**
     * @method process_module_settings
     */
	static public function process_module_settings($module, $new_settings)
	{
	    // Get a new node instance to work with.
        $class    = get_class(self::$modules[$module->settings->type]);
        $instance = new $class();

        // Run node delete to clear any cache.
        $instance->settings = $module->settings;
        $instance->delete();

        // Run node update.
        $instance->settings = $new_settings;
        $new_settings       = $instance->update($new_settings);

        return $new_settings;
	}

    /**
     * @method get_module_defaults
     */
    static public function get_module_defaults($type)
    {
        $defaults = new StdClass();

        if(isset(self::$modules[$type]->form)) {
            $defaults = self::get_settings_form_defaults( $type );
            $defaults->type = $type;
        }

        return $defaults;
    }

    /**
     * @method get_wp_widgets
     */
    static public function get_wp_widgets()
    {
        global $wp_widget_factory;

        $widgets = array();

        foreach($wp_widget_factory->widgets as $class => $widget) {
            $widget->class = $class;
            $widgets[$widget->name] = $widget;
        }

        ksort($widgets);

        return $widgets;
    }

    /**
     * @method get_wp_sidebars
     */
    static public function get_wp_sidebars()
    {
        global $wp_registered_sidebars;

        $sidebars = array();

        foreach($wp_registered_sidebars as $sidebar) {
            $sidebars[$sidebar['name']] = $sidebar;
        }

        ksort($sidebars);

        return $sidebars;
    }

	/**
     * @method load_settings
     */
	static public function load_settings()
	{
	    require_once FL_BUILDER_DIR . 'includes/global-settings.php';
        require_once FL_BUILDER_DIR . 'includes/row-settings.php';
        require_once FL_BUILDER_DIR . 'includes/column-settings.php';
        require_once FL_BUILDER_DIR . 'includes/module-settings.php';
        require_once FL_BUILDER_DIR . 'includes/user-template-settings.php';
	}

	/**
     * @method register_settings_form
     */
    static public function register_settings_form($id, $form)
    {
        self::$settings_forms[$id] = $form;
    }

	/**
     * @method get_settings_form
     */
    static public function get_settings_form( $id )
    {
        return self::$settings_forms[ $id ];
    }

	/**
     * @method get_settings_form_fields
     */
    static public function get_settings_form_fields($form)
    {
        $fields = array();

        foreach ( $form as $tab ) {
            if ( isset( $tab['sections'] ) ) {
                foreach ( $tab['sections'] as $section ) {
                    if ( isset( $section['fields'] ) ) {
                        foreach ( $section['fields'] as $name => $field ) {
                            $fields[ $name ] = $field;
                        }
                    }
                }
            }
        }

        return $fields;
    }

    /**
     * @method get_settings_form_defaults
     */
    static public function get_settings_form_defaults( $type )
    {
	    // Check to see if the defaults are cached first.
	    if ( isset( self::$settings_form_defaults[ $type ] ) ) {
		    return self::$settings_form_defaults[ $type ];
	    }
	    
	    // They aren't cached, let's get them.
	    $defaults = new StdClass();
	    
	    // Check the registered forms first.
	    if ( isset( self::$settings_forms[ $type ] ) ) {
		    $form_type = $type;
		    $tabs = self::$settings_forms[ $type ]['tabs'];
	    }
	    // If it's not a registered form, it must be a module form. 
	    else if ( isset( self::$modules[ $type ] ) ) {
		    $form_type = $type . '-module';
		    $tabs = self::$modules[ $type ]->form;
	    }
	    // The form can't be found. 
	    else {
		    return $defaults;
	    }
	    
	    // Loop through the tabs and get the defaults.
        foreach($tabs as $tab) {
            if(isset($tab['sections'])) {
                foreach($tab['sections'] as $section) {
                    if(isset($section['fields'])) {
                        foreach($section['fields'] as $name => $field) {

                            $default = isset($field['default']) ? $field['default'] : '';
                            $is_multiple = isset($field['multiple']) && $field['multiple'] === true;
                            $supports_multiple = $field['type'] != 'editor' && $field['type'] != 'photo';

                            if($is_multiple && $supports_multiple) {
                                $defaults->$name = array($default);
                            }
                            else {
                                $defaults->$name = $default;
                            }
                        }
                    }
                }
            }
        }
        
        // Cache the defaults.
        self::$settings_form_defaults[ $type ] = apply_filters( 'fl_builder_settings_form_defaults', $defaults, $form_type );

        return self::$settings_form_defaults[ $type ];
    }

    /**
     * @method save_settings
     */
    static public function save_settings($node_id = null, $settings = null)
    {
	    $post_data      = self::get_post_data();
        $node_id        = isset($post_data['node_id']) ? $post_data['node_id'] : $node_id;
        $settings       = isset($post_data['settings']) ? $post_data['settings'] : $settings;
        $node           = self::get_node($node_id);
        $new_settings   = (object)array_merge((array)$node->settings, (array)$settings);

        // Process the settings.
        $new_settings = self::process_node_settings($node, $new_settings);

        // Save the settings to the node.
        $data = self::get_layout_data();
        $data[$node_id]->settings = $new_settings;

        // Update the layout data.
        self::update_layout_data($data);

        // Return the new layout.
        if(defined('DOING_AJAX')) {
            FLBuilder::render_css();
            FLBuilder::render_js();
            FLBuilder::render_layout();
        }
    }

    /**
     * @method json_decode_settings
     */
    static public function json_decode_settings($data)
    {
        if(is_string($data)) {
            $data = json_decode(stripcslashes($data));
        }
        if(is_object($data) || is_array($data)) {

            foreach($data as $key => $val) {

                $new_val = null;

                if(is_string($val)) {

                    $decoded = json_decode(stripcslashes($val));

                    if(is_object($decoded) || is_array($decoded)) {
                        $new_val = $decoded;
                    }
                }
                else if(is_object($val) || is_array($val)) {
                    $new_val = self::json_decode_settings($val);
                }

                if($new_val) {

                    if(is_object($data)) {
                        $data->{$key} = $new_val;
                    }
                    else if(is_array($data)) {
                        $data[$key] = $new_val;
                    }
                }
            }
        }

        return $data;
    }

    /**
     * @method default_settings
     */
    static public function default_settings(&$settings, $defaults)
    {
        foreach($defaults as $name => $value) {
            if(!isset($settings->$name)) {
                $settings->$name = $value;
            }
        }
    }

    /**
     * @method get_global_defaults
     */
    static public function get_global_defaults()
    {
        return self::get_settings_form_defaults( 'global' );
    }

    /**
     * @method get_global_settings
     */
    static public function get_global_settings()
    {
        $settings = get_option('_fl_builder_settings');
        $defaults = self::get_global_defaults();

        if(!$settings) {
            $settings = new StdClass();
        }

        return (object)array_merge((array)$defaults, (array)$settings);
    }

    /**
     * @method save_global_settings
     */
    static public function save_global_settings($settings = array())
    {
	    $post_data      = self::get_post_data();
        $settings       = isset($post_data['settings']) ? $post_data['settings'] : $settings;
        $old_settings   = self::get_global_settings();
        $new_settings   = (object)array_merge((array)$old_settings, (array)$settings);

        return update_option('_fl_builder_settings', $settings);
    }

	/**
     * @method duplicate_post
     */
    static public function duplicate_post()
    {
        global $wpdb;

        $post_id      = self::get_post_id();
        $post         = get_post($post_id);
        $current_user = wp_get_current_user();

		// Duplicate the post.
		$data = array(
			'comment_status' => $post->comment_status,
			'ping_status'    => $post->ping_status,
			'post_author'    => $current_user->ID,
			'post_content'   => $post->post_content,
			'post_excerpt'   => $post->post_excerpt,
			'post_name'      => $post->post_name,
			'post_parent'    => $post->post_parent,
			'post_password'  => $post->post_password,
			'post_status'    => 'draft',
			'post_title'     => sprintf( _x( 'Copy of %s', '%s stands for post/page title.', 'fl-builder' ), $post->post_title ),
			'post_type'      => $post->post_type,
			'to_ping'        => $post->to_ping,
			'menu_order'     => $post->menu_order
		);

        // Get the new post id.
        $new_post_id = wp_insert_post($data);

        // Duplicate post meta.
        $post_meta = $wpdb->get_results("SELECT meta_key, meta_value FROM {$wpdb->postmeta} WHERE post_id= {$post_id}");

        if(count($post_meta) !== 0) {

            $sql = "INSERT INTO {$wpdb->postmeta} (post_id, meta_key, meta_value) ";

            foreach($post_meta as $meta_info) {
                $meta_key     = $meta_info->meta_key;
                $meta_value   = addslashes($meta_info->meta_value);
                $sql_select[] = "SELECT {$new_post_id}, '{$meta_key}', '{$meta_value}'";
            }

            $sql .= implode(" UNION ALL ", $sql_select);
            $wpdb->query($sql);
        }

        // Duplicate post terms.
        $taxonomies = get_object_taxonomies($post->post_type);

		foreach($taxonomies as $taxonomy) {

			$post_terms = wp_get_object_terms($post_id, $taxonomy);

			for($i = 0; $i < count($post_terms); $i++) {
				wp_set_object_terms($new_post_id, $post_terms[$i]->slug, $taxonomy, true);
			}
		}

		// Get the duplicated layout data.
		$data = self::get_layout_data('published', $new_post_id);

		// Generate new node ids.
		$data = self::generate_new_node_ids($data);

		// Save the duplicated layout data.
		self::update_layout_data($data, 'published', $new_post_id);

        // Return the new post id.
        return $new_post_id;
    }

	/**
     * @method delete_post
     */
    static public function delete_post($post_id)
    {
        // Delete all published and draft data.
        self::delete_layout_data('published', $post_id);
        self::delete_layout_data('draft', $post_id);

        // Delete all css and js.
        self::delete_all_asset_cache($post_id);
    }

	/**
     * @method save_revision
     */
    static public function save_revision($post_id)
    {
        $parent_id = wp_is_post_revision($post_id);

        if($parent_id) {

            $parent  = get_post($parent_id);
            $data    = self::get_layout_data('published', $parent->ID);

            if(!empty($data)) {
                self::update_layout_data($data, 'published', $post_id);
            }
        }
    }

	/**
     * @method restore_revision
     */
    static public function restore_revision($post_id, $revision_id)
    {
        $post     = get_post($post_id);
        $revision = get_post($revision_id);

        if($revision) {

            $data = self::get_layout_data('published', $revision->ID);

            if(!empty($data)) {
                self::update_layout_data($data, 'published', $post_id);
                self::update_layout_data($data, 'draft', $post_id);
            }
            else {
                self::delete_layout_data('published', $post_id);
                self::delete_layout_data('draft', $post_id);
            }

            self::delete_all_asset_cache();
        }
    }

	/**
     * We use get_metadata here instead of get_post_meta,
     * to ensure revisions are queried accordingly.
     *
     * @method get_layout_data
     */
	static public function get_layout_data($status = null, $post_id = null)
	{
	    $post_id    = !$post_id ? self::get_post_id() : $post_id;
	    $status     = !$status ? self::get_node_status() : $status;

	    // Get published data?
	    if($status == 'published') {
    	    if(isset(self::$published_layout_data[$post_id])) {
        	    $data = self::$published_layout_data[$post_id];
    	    }
    	    else {
        	    $data = get_metadata('post', $post_id, '_fl_builder_data', true);
        	    self::$published_layout_data[$post_id] = self::clean_layout_data( $data );
    	    }
	    }
	    // Get draft data?
	    else if($status == 'draft') {
    	    if(isset(self::$draft_layout_data[$post_id])) {
        	    $data = self::$draft_layout_data[$post_id];
    	    }
    	    else {
        	    $data = get_metadata('post', $post_id, '_fl_builder_draft', true);
        	    self::$draft_layout_data[$post_id] = self::clean_layout_data( $data );
    	    }
	    }

	    // Make sure we have an array.
	    if(empty($data)) {
    	    $data = array();
	    }

	    // Clone the layout data to ensure the cache remains intact.
	    foreach($data as $node_id => $node) {
    	    $data[$node_id] = clone $node;
	    }

        // Return the data.
	    return $data;
	}

	/**
     * We use update_metadata here instead of update_post_meta,
     * to ensure revisions are updated accordingly.
     *
     * @method update_layout_data
     */
	static public function update_layout_data($data, $status = null, $post_id = null)
	{
	    $post_id    = !$post_id ? self::get_post_id() : $post_id;
	    $status     = !$status ? self::get_node_status() : $status;
		$data 		= self::clean_layout_data( $data );

	    // Update published data?
	    if($status == 'published') {
    	    update_metadata('post', $post_id, '_fl_builder_data', $data);
    	    self::$published_layout_data[$post_id] = $data;
	    }
	    // Update draft data?
	    else if($status == 'draft') {
    	    update_metadata('post', $post_id, '_fl_builder_draft', $data);
    	    self::$draft_layout_data[$post_id] = $data;
	    }
	}

	/**
     * @method delete_layout_data
     */
	static public function delete_layout_data($status = null, $post_id = null)
	{
        // Make sure we have a status to delete.
        if(!$status) {
            return;
        }

	    // Get the post id.
	    $post_id = !$post_id ? self::get_post_id() : $post_id;

        // Get the data to delete.
        $data = self::get_layout_data($status, $post_id);

        // Delete the nodes.
        foreach($data as $node) {
            self::call_module_delete($node);
        }

        // Update the layout data.
        self::update_layout_data(array(), $status, $post_id);
	}

	/**
	 * Ensures the integrity of layout data key/value pairs.
	 *
     * @method clean_layout_data
     */	 
	static public function clean_layout_data( $data = array() )
	{
		$cleaned = array();
		
		if ( is_array( $data ) ) {
			foreach ( $data as $node ) {
				$cleaned[$node->node] = $node;
			}
		}
		
		return $cleaned;
	}
    
	/**
     * @method clear_draft_layout
     */
    static public function clear_draft_layout()
    {
        $post_id = self::get_post_id();
        $data    = self::get_layout_data('published', $post_id);

        // Delete the old draft layout.
        self::delete_layout_data('draft');

        // Save the new draft layout.
        self::update_layout_data($data, 'draft', $post_id);

        // Clear the asset cache.
        self::delete_all_asset_cache($post_id);
    }

	/**
     * @method save_layout
     */
    static public function save_layout()
    {
        $editor_content = FLBuilder::render_editor_content();
        $post_id        = self::get_post_id();
        $data           = self::get_layout_data('draft', $post_id);

        // Delete the old published layout.
        self::delete_layout_data('published', $post_id);

        // Save the new published layout.
        self::update_layout_data($data, 'published', $post_id);

        // Clear the asset cache.
        self::delete_all_asset_cache($post_id);

        // Enable the builder to take over the post content.
        self::enable();

        // Get the post status.
        $post_status = get_post_status($post_id);
        $post_status = strstr($post_status, 'draft') ? 'publish' : $post_status;

        // Update the post with stripped down content.
        wp_update_post(array(
            'ID'            => self::get_post_id(),
            'post_status'   => $post_status,
            'post_content'  => $editor_content
        ));
    }

	/**
	 * Duplicates a layout for WPML when the copy from original
	 * button has been clicked.
	 *
     * @method duplicate_wpml_layout
     */
    static public function duplicate_wpml_layout($original_post_id = null, $new_post_id = null)
    {
        $post_data          = self::get_post_data();
        $original_post_id   = isset($post_data['original_post_id']) ? $post_data['original_post_id'] : $original_post_id;
        $new_post_id        = isset($post_data['post_id']) ? $post_data['post_id'] : $new_post_id;
        $enabled            = get_post_meta($original_post_id, '_fl_builder_enabled', true);
        $published          = self::get_layout_data('published', $original_post_id);
        $draft              = self::get_layout_data('draft', $original_post_id);

        $response = array(
            'enabled'    => false,
            'has_layout' => false
        );

        if(!empty($enabled)) {
            update_post_meta($new_post_id, '_fl_builder_enabled', true);
            $response['enabled'] = true;
        }
        if(!empty($published)) {
            self::update_layout_data($published, 'published', $new_post_id);
            $response['has_layout'] = true;
        }
        if(!empty($draft)) {
            self::update_layout_data($draft, 'draft', $new_post_id);
            $response['has_layout'] = true;
        }

        return $response;
    }

	/**
     * @method get_enabled_templates
     */
	static public function get_enabled_templates()
	{
    	$key        = '_fl_builder_enabled_templates';
    	$default    = 'enabled';

	    // Get the value.
    	if(is_network_admin()) {
        	$value = get_site_option($key);
    	}
    	else if(class_exists('FLBuilderMultisiteSettings')) {
        	$value = get_option($key);
        	$value = !$value ? get_site_option($key) : $value;
        }
        else {
            $value = get_option($key);
        }

    	// Return the value.
	    if(!$value) {
    	    return $default;
	    }
	    else {
    	    return $value;
	    }
	}

	/**
     * @method save_user_template
     */
    static public function save_user_template()
    {
        $post_data = self::get_post_data();

        $post_id = wp_insert_post(array(
            'post_title'     => $post_data['template_name'],
            'post_type'      => 'fl-builder-template',
            'post_status'    => 'publish',
            'ping_status'    => 'closed',
            'comment_status' => 'closed'
        ));

		// Get the layout data to copy.
		$data = self::get_layout_data();

		// Generate new node ids.
		$data = self::generate_new_node_ids($data);

		// Save the template layout data.
		self::update_layout_data($data, 'published', $post_id);
    }

	/**
     * @method get_user_templates
     */
    static public function get_user_templates()
    {
        return get_posts('post_type=fl-builder-template&orderby=title&order=ASC&posts_per_page=-1');
    }

	/**
     * @method delete_user_template
     */
    static public function delete_user_template($template_id = null)
    {
        $post_data   = self::get_post_data();
        $template_id = isset($post_data['template_id']) ? $post_data['template_id'] : $template_id;

        if(isset($template_id)) {
            wp_delete_post($template_id, true);
        }
    }

	/**
     * @method apply_user_template
     */
    static public function apply_user_template($template_id = null, $append = false)
    {
        $post_data      = self::get_post_data();
        $template_id    = isset($post_data['template_id']) ? $post_data['template_id'] : $template_id;
        $append       	= isset($post_data['append']) ? $post_data['append'] : $append;
        $row_position   = self::next_node_position('row');

        if(isset($template_id)) {

            // Delete existing nodes?
            if(!$append) {
                self::delete_layout_data('draft');
            }

            // Insert new nodes if this is not a blank template.
            if($template_id != 'blank') {

                // Get the template data.
                $template_data = self::get_layout_data('published', $template_id);

                // Get new ids for the template nodes.
                $template_data = self::generate_new_node_ids($template_data);

                // Get the existing layout data.
                $layout_data = self::get_layout_data();

                // Reposition rows?
                if($append) {

                    foreach($template_data as $node_id => $node) {

                        if($node->type == 'row') {
                            $template_data[$node_id]->position += $row_position;
                        }
                    }
                }

                // Merge the data.
                $data = array_merge($layout_data, $template_data);

                // Update the layout data.
                self::update_layout_data($data);
            }

            // Delete old asset cache.
            self::delete_all_asset_cache();
        }
    }

	/**
     * @method save_template
     */
    static public function save_template($settings)
    {
        // Get the layout data.
        $data = self::get_layout_data();

        // Get the templates array.
        $templates = self::get_templates();

        // Get new ids for the nodes.
        $settings->nodes = self::generate_new_node_ids($data);

        // Insert the template into the templates array.
        array_splice($templates, $settings->index, 0, array($settings));

        // Save the templates array.
        self::save_templates($templates);
    }

	/**
     * @method update_template
     */
    static public function update_template($old_index, $settings)
    {
        // Get the templates array.
        $templates = self::get_templates();

        // Remove the template from its old position.
        $template = array_splice($templates, $old_index, 1);

        // Update the settings
        foreach($settings as $key => $val) {
            $template[0]->$key = $val;
        }

        // Add the template to its new position.
        array_splice($templates, $settings->index, 0, $template);

        // Save the templates array.
        self::save_templates($templates);
    }

	/**
     * @method delete_template
     */
    static public function delete_template($index)
    {
        // Get the templates array.
        $templates = self::get_templates();

        // Remove the template.
        array_splice($templates, $index, 1);

        // Save the templates array.
        self::save_templates($templates);
    }

	/**
     * @method apply_template
     */
    static public function apply_template($index = 0, $append = false)
    {
        $post_data      = self::get_post_data();
        $index       	= isset($post_data['index']) ? $post_data['index'] : $index;
        $append       	= isset($post_data['append']) ? $post_data['append'] : $append;
        $template       = self::get_template($index);
        $row_position   = self::next_node_position('row');

        // Delete existing nodes?
        if(!$append) {
            self::delete_layout_data('draft');
        }

        // Only move forward if we have template nodes.
        if(isset($template->nodes)) {

            // Get new ids for the template nodes.
            $template_data = self::generate_new_node_ids($template->nodes);

            // Get the existing layout data.
            $layout_data = self::get_layout_data();

            // Reposition rows?
            if($append) {

                foreach($template_data as $node_id => $node) {

                    if($node->type == 'row') {
                        $template_data[$node_id]->position += $row_position;
                    }
                }
            }

            // Merge the data.
            $data = array_merge($layout_data, $template_data);

            // Update the layout data.
            self::update_layout_data($data);
        }

        // Delete old asset cache.
        self::delete_all_asset_cache();
    }

	/**
     * @method get_template
     */
    static public function get_template($index)
    {
        $templates = self::get_templates();

        return $templates[$index];
    }

	/**
     * @method get_templates
     */
    static public function get_templates()
    {
        $templates = unserialize(file_get_contents(FL_BUILDER_DIR . 'data/templates.dat'));

        return is_array($templates) ? $templates : array();
    }

	/**
     * @method save_templates
     */
    static public function save_templates($templates = array())
    {
    	// Update the indexes for proper positioning.
    	$i = 0;
    	$updated = array();

    	foreach($templates as $template) {
	    	$template->index = $i;
	    	$updated[$i] = $template;
	    	$i++;
    	}

    	// Save the templates array.
        file_put_contents(FL_BUILDER_DIR . 'data/templates.dat', serialize($updated));
    }

	/**
     * @method get_branding
     */
    static public function get_branding()
    {
    	$key        = '_fl_builder_branding';
    	$default    = __('Page Builder', 'fl-builder');

	    // Get the value.
    	if(is_network_admin() || class_exists('FLBuilderMultisiteSettings')) {
        	$value = get_site_option($key);
    	}
        else {
            $value = get_option($key);
        }

    	// Return the value.
	    if(!$value) {
    	    return $default;
	    }
	    else {
    	    return stripcslashes($value);
	    }
    }

	/**
     * @method get_branding_icon
     */
    static public function get_branding_icon()
    {
    	$key        = '_fl_builder_branding_icon';
    	$default    = FL_BUILDER_URL . 'img/beaver.png';

	    // Get the value.
    	if(is_network_admin() || class_exists('FLBuilderMultisiteSettings')) {
        	$value = get_site_option($key);
    	}
        else {
            $value = get_option($key);
        }

    	// Return the value.
	    if($value === false) {
    	    return $default;
	    }
	    else {
    	    return $value;
	    }
    }

	/**
     * @method get_enabled_icons
     */
    static public function get_enabled_icons()
    {
    	$key        = '_fl_builder_enabled_icons';
    	$default    = array( 'font-awesome', 'foundation-icons', 'dashicons' );

	    // Get the value.
    	if(is_network_admin()) {
        	$value = get_site_option($key);
    	}
    	else if(class_exists('FLBuilderMultisiteSettings')) {
        	$value = get_option($key);
        	$value = !$value ? get_site_option($key) : $value;
        }
        else {
            $value = get_option($key);
        }

    	// Return the value.
	    if(!$value) {
    	    return $default;
	    }
	    else {
    	    return $value;
	    }
    }

	/**
     * @method get_editing_capability
     */
    static public function get_editing_capability()
    {
    	$key        = '_fl_builder_editing_capability';
    	$default    = 'edit_posts';

	    // Get the value.
    	if(is_network_admin()) {
        	$value = get_site_option($key);
    	}
    	else if(class_exists('FLBuilderMultisiteSettings')) {
        	$value = get_option($key);
        	$value = !$value ? get_site_option($key) : $value;
        }
        else {
            $value = get_option($key);
        }

    	// Return the value.
	    if(!$value) {
    	    return $default;
	    }
	    else {
    	    return $value;
	    }
    }

	/**
     * @method plugin_basename
     */
    static public function plugin_basename()
    {
	    return plugin_basename( FL_BUILDER_DIR . 'fl-builder.php' );
	}

	/**
     * We don't delete _fl_builder_enabled, _fl_builder_data and _fl_builder_draft
     * so layouts can be recovered should the plugin be installed again.
     *
     * @method uninstall_database
     */
    static public function uninstall_database()
    {
        if(current_user_can('delete_plugins')) {

            // Delete builder settings.
            delete_option('_fl_builder_settings');
            delete_option('_fl_builder_enabled_modules');
            delete_option('_fl_builder_enabled_templates');
            delete_option('_fl_builder_post_types');
            delete_option('_fl_builder_enabled_icons');
            delete_option('_fl_builder_branding');
            delete_option('_fl_builder_editing_capability');

            // Delete uploaded files and folders.
            $upload_dir  = self::get_upload_dir();
            $filesystem  = FLBuilderUtils::get_filesystem();
            $filesystem->rmdir( $upload_dir['path'], true );

            // Deactivate and delete the plugin.
            deactivate_plugins(array(self::plugin_basename()), false, is_network_admin());
            delete_plugins(array(self::plugin_basename()));

            // Redirect to the plugins page.
            wp_redirect(admin_url('plugins.php?deleted=true&plugin_status=all&paged=1&s='));
            
            exit;
        }
    }
}